flowchart TB
    subgraph Keys[Key Mapping]
        CacheKey[CacheKey<br/>Pingora's cache key<br/>e.g. GET /image.jpg?v=1]
        Hash[Hash Function<br/>blake3 / sha256]
        ObjectId[ObjectId<br/>Stable blob key<br/>e.g. v1/abc123...]
        
        CacheKey -->|hash| Hash
        Hash -->|generates| ObjectId
    end
    
    subgraph ManifestStruct[Manifest Structure]
        direction TB
        M[Manifest Record]
        
        M1[object: ObjectId<br/>Points to blob in BlobStore]
        M2[len: u64<br/>Content length in bytes]
        M3[etag: Option&lt;String&gt;<br/>Blob integrity tag]
        M4[meta_blob: Vec&lt;u8&gt;<br/>Serialized CacheMeta<br/>Headers, status, etc]
        M5[expires_at: SystemTime<br/>Authoritative TTL<br/>Parsed from Cache-Control]
        M6[version: u64<br/>For CAS updates<br/>Prevents race conditions]
        
        M --> M1
        M --> M2
        M --> M3
        M --> M4
        M --> M5
        M6 --> M
    end
    
    subgraph Storage[Storage Locations]
        direction LR
        IndexDB[IndexStore<br/>Key: CacheKey bytes<br/>Value: Manifest]
        BlobDB[BlobStore<br/>Key: ObjectId<br/>Value: HTTP body bytes]
        
        IndexDB -->|points to| BlobDB
    end
    
    subgraph Operations[CRUD Operations]
        direction TB
        
        subgraph Write[Write Path Miss]
            W1[1. Origin fetch complete]
            W2[2. Upload body to BlobStore<br/>ObjectId â†’ body stream]
            W3[3. Get ObjectMeta<br/>len, etag from blob]
            W4[4. Build Manifest<br/>Serialize CacheMeta<br/>Calculate TTL]
            W5[5. IndexStore.put_new<br/>Atomic: first writer wins]
            
            W1 --> W2
            W2 --> W3
            W3 --> W4
            W4 --> W5
        end
        
        subgraph Read[Read Path Hit]
            R1[1. IndexStore.get CacheKey]
            R2[2. Validate TTL<br/>expires_at > now?]
            R3[3. Deserialize CacheMeta]
            R4[4. BlobStore.get ObjectId]
            R5[5. Stream body to client]
            
            R1 --> R2
            R2 -->|Valid| R3
            R3 --> R4
            R4 --> R5
            R2 -->|Expired| RMiss[Return Miss]
        end
        
        subgraph Update[Update Meta]
            U1[1. IndexStore.get current]
            U2[2. Modify meta_blob<br/>Update expires_at]
            U3[3. IndexStore.cas_update<br/>Verify version unchanged]
            U4{CAS success?}
            U5[Done]
            U6[Retry]
            
            U1 --> U2
            U2 --> U3
            U3 --> U4
            U4 -->|Yes| U5
            U4 -->|No conflict| U6
            U6 --> U1
        end
        
        subgraph Purge[Purge]
            P1[PurgeType: Soft vs Hard]
            P2[1. IndexStore.get manifest]
            P3[2. IndexStore.delete]
            P4{Hard purge?}
            P5[3. BlobStore.delete ObjectId]
            P6[Done]
            
            P1 --> P2
            P2 --> P3
            P3 --> P4
            P4 -->|Yes| P5
            P4 -->|No| P6
            P5 --> P6
        end
    end
    
    CacheKey -.->|stored as key| IndexDB
    ObjectId -.->|stored as key| BlobDB
    M1 -.->|references| ObjectId
    
    style CacheKey fill:#FFD700
    style ObjectId fill:#FFB6C6
    style M fill:#87CEEB
    style M4 fill:#90EE90
    style M5 fill:#DDA0DD
    style M6 fill:#FFE4B5
    style IndexDB fill:#DDA0DD
    style BlobDB fill:#FFB6C6
    style W5 fill:#90EE90
    style R5 fill:#90EE90
    style U3 fill:#87CEEB
    style P5 fill:#F08080
